using GoopGame.Utility;
using UnityEngine;

namespace GoopGame.Data
{
    /// <summary>
    /// Color implementation of <seealso cref="GoopTraitData{T}"/>
    /// </summary>
    [CreateAssetMenu(
        fileName = "GoopColorTrait", 
        menuName = "GoopGame/Goops/Traits/Create new Goop Color Trait"
        )]
    public class GoopTraitDataColor : GoopTraitData<Color>
    {
        /// <summary>
        /// A gradient of the colors generated by default and mutations.
        /// Provides a range of colors along with probability determined
        /// by the space each color takes up.
        /// </summary>
        public Gradient DefaultColors;

        /// <summary>
        /// The maximum mutation range.
        /// </summary>
        public float MutationRange;

        /// <summary>
        /// The probability of generating a color with length 
        /// -MutationRange to MutationRange to add to base color.
        /// </summary>
        public ProbabilityCurve MutationRangeProbability;

        public override Color GenerateRandomValue()
        {
            //Sample random x from gradient.
            return DefaultColors.Evaluate(Random.Range(0f, 1f));
        }

        public override Color GenerateCombineValue(Color value1, 
            Color value2, GoopWeightStruct weights1, 
            GoopWeightStruct weights2
            )
        {
            //Calculate parent lerp value, and combine.
            float parentCombinationRatio = 
                ParentsLerpProbability.GetValue(Random.Range(0f, 1f));

            //Normalize the delta and multiply by lerp value.
            Color delta = 
                NormalizeColor(value2 - value1) * parentCombinationRatio;

            //...then add multiplied delta to origin to get blended color.
            Color combinedValue = value1 + delta;

            //Get combined struct
            GoopWeightStruct combinedStruct = new GoopWeightStruct(
                weights1, weights2, parentCombinationRatio
                );

            //Evaluate biases.
            foreach (var bias in EvolutionWeights)
            {
                if (bias.IsBiasApplied(combinedStruct))
                    ApplyBias(ref combinedValue, bias);
            }

            //Single mutation step.
            DoMutation(ref combinedValue);

            return combinedValue;
        }

        public override (Color, Color) GenerateSplitValues(Color value, 
            GoopWeightStruct weights
            )
        {
            //Store values on stack to be passed by reference.
            Color value1 = value;
            Color value2 = value;

            //Evaluate biases.
            foreach (var bias in EvolutionWeights)
            {
                if (bias.IsBiasApplied(weights))
                    ApplyBias(ref value1, bias);
                if (bias.IsBiasApplied(weights))
                    ApplyBias(ref value2, bias);
            }

            //Single mutation step.
            DoMutation(ref value1);
            DoMutation(ref value2);

            return (value1, value2);
        }

        public override void ApplyBias(ref Color value, EvolutionBias bias)
        {
            //Clamp colors within 0-1rgba range
            //(Since we do not display HDR colors, we should leave them
            //out of calculations as well.)
            Color delta = ClampColor(bias.BiasTarget - value);
            
            //Separate magnitude and direction of delta color.
            float magnitude = ColorMagnitude(delta);

            //Multiply normalized mutation by generated intensity.
            delta = NormalizeColor(delta) * 
                Mathf.Min(magnitude, MutationRange) * 
                bias.BiasIntensityProbability.Evaluate(
                    Random.Range(0f, 1f)
                    );
            value += delta;
        }

        public override void DoMutation(ref Color value)
        {
            //Get random mutation intensity.
            float mutationIntensity = MutationRangeProbability.GetValue(
                Random.Range(0f, 1f)
                );

            //Scale to mutation range.
            float mutation = Mathf.Lerp(
                0f, MutationRange, 
                //Since other traits use a symmetrical curve, we center
                //and absolute this curve despite it being "linear", so
                //that the frontend traits use the same MutationCurve format.
                //tl;dr: convert normal-dist 0-1 to linear 0-1
                Mathf.Abs(mutationIntensity * 2f - 1f)
                );

            //Get random value from gradient as target.
            Color target = GenerateRandomValue();

            //Mutate towards target by taking normalized delta
            Color delta = NormalizeColor(target - value);
            //... and multiplying by generated mutation range.
            value += delta * mutation;
        }

        /// <summary>
        /// Helper function to clamp a color within non-HDR space.
        /// </summary>
        public static Color ClampColor(Color color)
        {
            return new Color(
                Mathf.Clamp01(color.r),
                Mathf.Clamp01(color.g),
                Mathf.Clamp01(color.b),
                Mathf.Clamp01(color.a)
                );
        }

        /// <summary>
        /// Helper function to get magnitude of Vector4 of Color.
        /// </summary>
        public static float ColorMagnitude(Color color)
        {
            float magnitude = color.r * color.r + color.g * color.g +
                color.b * color.b + color.a * color.a;

            return Mathf.Sqrt(magnitude);
        }

        /// <summary>
        /// Helper function to normalize a Vector4 of Color.
        /// </summary>
        public static Color NormalizeColor(Color color)
        {
            float magnitude = ColorMagnitude(color);

            //Avoid NaN error
            if (magnitude == 0f)
                return new Color(0f, 0f, 0f, 0f);

            return new Color(
                color.r / magnitude, color.g / magnitude,
                color.b / magnitude, color.a / magnitude
                );
        }
    }
}
